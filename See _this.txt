I can see the issues! Let me fix the npm problems, update the dependencies, and integrate the EliteProTech APIs. The APIs look perfect for our needs!

Fix 1: Clean npm install and update dependencies

```bash
# First, clean everything
rm -rf node_modules package-lock.json
npm cache clean --force

# Create new package.json with correct dependencies
cat > package.json << 'EOF'
{
  "name": "megan-bot-proper",
  "version": "3.0.0",
  "description": "Professional WhatsApp Bot with AI and Advanced Features",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js",
    "pair": "node src/pair.js",
    "clean": "rm -rf session data/cache",
    "reset": "npm run clean && npm run pair"
  },
  "dependencies": {
    "@whiskeysockets/baileys": "7.0.0-rc.9",
    "axios": "^1.6.0",
    "sharp": "^0.34.5",
    "link-preview-js": "^3.2.0",
    "moment-timezone": "^0.6.0",
    "moment": "^2.29.4",
    "pino": "^8.15.0",
    "chalk": "^4.1.2",
    "qrcode-terminal": "^0.12.0",
    "dotenv": "^16.3.1",
    "fs-extra": "^11.1.1",
    "node-cache": "^5.1.2",
    "fluent-ffmpeg": "^2.1.2",
    "ffmpeg-static": "^5.2.0",
    "cheerio": "^1.0.0-rc.12",
    "form-data": "^4.0.0",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  },
  "keywords": ["whatsapp", "bot", "ai", "automation", "professional"],
  "author": "Tracker Wanga",
  "license": "MIT"
}
EOF
```

Fix 2: Update logger to fix pino-pretty issue

```bash
cat > src/utils/logger.js << 'EOF'
const pino = require('pino');
const chalk = require('chalk');
const moment = require('moment-timezone');
const config = require('../../config/config');

class MeganLogger {
    constructor() {
        this.timezone = config.TIMEZONE;
        this.botName = config.BOT_NAME;
        
        // Create Pino logger for Baileys with simple config
        this.pinoLogger = pino({
            level: config.LOG_LEVEL,
            transport: config.DEBUG ? undefined : undefined // Remove pino-pretty for now
        });
        
        // Colors
        this.colors = {
            info: chalk.cyan,
            success: chalk.green,
            warning: chalk.yellow,
            error: chalk.red,
            debug: chalk.magenta,
            system: chalk.blue,
            incoming: chalk.green.bold,
            outgoing: chalk.blue.bold,
            command: chalk.yellow.bold,
            ai: chalk.magenta.bold
        };
        
        // Emojis
        this.emojis = {
            info: 'â„¹ï¸',
            success: 'âœ…',
            warning: 'âš ï¸',
            error: 'âŒ',
            debug: 'ðŸ›',
            incoming: 'ðŸ“¥',
            outgoing: 'ðŸ“¤',
            command: 'âŒ¨ï¸',
            ai: 'ðŸ¤–',
            group: 'ðŸ‘¥',
            private: 'ðŸ‘¤',
            media: 'ðŸ–¼ï¸',
            link: 'ðŸ”—',
            music: 'ðŸŽµ',
            video: 'ðŸŽ¬',
            image: 'ðŸ–¼ï¸',
            time: 'â°'
        };
    }

    getTimestamp() {
        return moment().tz(this.timezone).format('HH:mm:ss');
    }

    formatMessage(level, message, emoji = '', context = '') {
        const timestamp = chalk.gray(`[${this.getTimestamp()}]`);
        const botTag = chalk.magenta(`[${this.botName}]`);
        const levelColor = this.colors[level] || chalk.white;
        const contextTag = context ? chalk.gray(`[${context}]`) : '';
        
        return `${timestamp} ${botTag} ${emoji} ${levelColor(message)} ${contextTag}`;
    }

    // Public logging methods
    log(message, level = 'info', emoji = '', context = '') {
        const formatted = this.formatMessage(level, message, emoji, context);
        console.log(formatted);
    }

    info(message, context = '') {
        this.log(message, 'info', this.emojis.info, context);
    }

    success(message, context = '') {
        this.log(message, 'success', this.emojis.success, context);
    }

    warning(message, context = '') {
        this.log(message, 'warning', this.emojis.warning, context);
    }

    error(message, context = '') {
        this.log(message, 'error', this.emojis.error, context);
    }

    debug(message, context = '') {
        if (config.DEBUG) {
            this.log(message, 'debug', this.emojis.debug, context);
        }
    }

    // Specialized loggers
    incomingMessage(msg, isGroup = false) {
        const type = isGroup ? 'GROUP' : 'PVT';
        const from = msg.key.remoteJid.split('@')[0];
        const text = this.extractMessageText(msg);
        const shortText = text ? text.substring(0, 50) : '[Media]';
        
        this.log(`${type}: ${from} - ${shortText}`, 'incoming', 
                 isGroup ? this.emojis.group : this.emojis.private, 'MSG');
    }

    outgoingMessage(to, message, isForwarded = false) {
        const toShort = to.split('@')[0];
        const type = isForwarded ? 'FWD' : 'SENT';
        this.log(`${type} to ${toShort}: ${this.getMessageType(message)}`, 
                 'outgoing', this.emojis.outgoing, 'SEND');
    }

    commandLog(command, from, args = []) {
        const fromShort = from.split('@')[0];
        const argsStr = args.length > 0 ? ` ${args.join(' ')}` : '';
        this.log(`${fromShort} - ${command}${argsStr}`, 'command', this.emojis.command, 'CMD');
    }

    aiResponse(prompt, response, model = '') {
        const shortPrompt = prompt.substring(0, 30);
        const shortResponse = response.substring(0, 30);
        this.log(`AI: "${shortPrompt}..." â†’ "${shortResponse}..."`, 'ai', this.emojis.ai, model);
    }

    connection(status, details = '') {
        const statusEmojis = {
            connecting: 'ðŸ”Œ',
            connected: 'âœ…',
            disconnected: 'âŒ',
            reconnecting: 'ðŸ”„'
        };
        this.log(`${status}: ${details}`, 'system', statusEmojis[status] || 'âš¡', 'CONN');
    }

    apiRequest(api, endpoint, status = 'success') {
        const emoji = status === 'success' ? 'âœ…' : 'âŒ';
        this.log(`${api}: ${endpoint}`, status === 'success' ? 'info' : 'error', emoji, 'API');
    }

    // Helper methods
    extractMessageText(msg) {
        if (!msg.message) return '';
        if (msg.message.conversation) return msg.message.conversation;
        if (msg.message.extendedTextMessage?.text) return msg.message.extendedTextMessage.text;
        if (msg.message.imageMessage?.caption) return msg.message.imageMessage.caption;
        if (msg.message.videoMessage?.caption) return msg.message.videoMessage.caption;
        if (msg.message.documentMessage?.title) return msg.message.documentMessage.title;
        return '';
    }

    getMessageType(message) {
        if (message.text) return `Text: ${message.text.substring(0, 30)}...`;
        if (message.image) return 'Image';
        if (message.video) return 'Video';
        if (message.audio) return 'Audio';
        if (message.sticker) return 'Sticker';
        if (message.contact) return 'Contact';
        if (message.location) return 'Location';
        if (message.poll) return 'Poll';
        return 'Unknown';
    }
}

// Export simple logger for Baileys
const simpleLogger = pino({ level: 'silent' });

// Export both
module.exports = simpleLogger;
module.exports.MeganLogger = MeganLogger;
module.exports.createLogger = () => new MeganLogger();
EOF
```

Fix 3: Update pairing script

```bash
cat > src/pair.js << 'EOF'
const qrcode = require('qrcode-terminal');
const { default: makeWASocket, useMultiFileAuthState, fetchLatestBaileysVersion, Browsers } = require('@whiskeysockets/baileys');
const fs = require('fs-extra');
const path = require('path');

async function pairDevice() {
    console.log('ðŸ“± WhatsApp Bot Pairing Tool\n');
    console.log('ðŸ’¡ On your phone: WhatsApp â†’ Settings â†’ Linked Devices â†’ Link a Device\n');
    
    try {
        // Check if session already exists
        const sessionPath = path.join(__dirname, '../../session');
        if (await fs.pathExists(path.join(sessionPath, 'creds.json'))) {
            console.log('âš ï¸  Session already exists.\n');
            
            const readline = require('readline').createInterface({
                input: process.stdin,
                output: process.stdout
            });
            
            const answer = await new Promise(resolve => {
                readline.question('Delete existing session and re-pair? (yes/no): ', resolve);
            });
            
            readline.close();
            
            if (answer.toLowerCase() !== 'yes') {
                console.log('âœ… Using existing session.');
                return;
            }
            
            await fs.remove(sessionPath);
            console.log('ðŸ—‘ï¸  Old session deleted.\n');
        }
        
        // Create fresh session
        const { state, saveCreds } = await useMultiFileAuthState(sessionPath);
        const { version } = await fetchLatestBaileysVersion();
        
        console.log('ðŸ”— Creating connection...\n');
        
        const sock = makeWASocket({
            version,
            auth: state,
            printQRInTerminal: false,
            browser: Browsers.macOS('Desktop'),
            connectTimeoutMs: 60000
        });
        
        // Save credentials when updated
        sock.ev.on('creds.update', saveCreds);
        
        // Handle QR code
        sock.ev.on('connection.update', ({ qr, connection }) => {
            if (qr) {
                console.log('ðŸ“¶ Scan this QR code with WhatsApp:\n');
                qrcode.generate(qr, { small: true });
                console.log('\nâ³ Waiting for scan... (Timeout: 2 minutes)\n');
            }
            
            if (connection === 'open') {
                console.log('âœ… Successfully paired!');
                console.log('ðŸš€ You can now start the bot with: npm start');
                process.exit(0);
            }
        });
        
        // Handle errors
        sock.ev.on('connection.update', ({ connection, lastDisconnect }) => {
            if (connection === 'close') {
                const error = lastDisconnect?.error;
                if (error?.output?.statusCode === 401) {
                    console.log('âŒ Session expired. Please re-pair.');
                    process.exit(1);
                }
            }
        });
        
        // Auto-exit after 2 minutes
        setTimeout(() => {
            console.log('\nâ° QR code expired. Please restart pairing.');
            process.exit(1);
        }, 2 * 60 * 1000);
        
    } catch (error) {
        console.error('âŒ Pairing failed:', error.message);
        process.exit(1);
    }
}

// Run pairing
pairDevice();
EOF
```

Create EliteProTech API Module

```bash
cat > src/modules/EliteProTechAPI.js << 'EOF'
const axios = require('axios');
const config = require('../../config/config');

class EliteProTechAPI {
    constructor() {
        this.baseURL = 'https://eliteprotech-apis.zone.id';
        this.timeout = 30000; // 30 seconds
        this.cache = new Map();
        this.cacheTTL = 5 * 60 * 1000; // 5 minutes
    }

    async request(endpoint, params = {}, method = 'GET') {
        try {
            const cacheKey = `${endpoint}:${JSON.stringify(params)}`;
            const cached = this.cache.get(cacheKey);
            
            if (cached && (Date.now() - cached.timestamp) < this.cacheTTL) {
                return cached.data;
            }
            
            const url = `${this.baseURL}${endpoint}`;
            const options = {
                method,
                timeout: this.timeout,
                headers: {
                    'User-Agent': 'MeganBot/3.0.0'
                }
            };
            
            if (method === 'GET') {
                options.params = params;
            } else {
                options.data = params;
            }
            
            const response = await axios(url, options);
            
            // Cache successful responses
            if (response.data.success) {
                this.cache.set(cacheKey, {
                    data: response.data,
                    timestamp: Date.now()
                });
            }
            
            return response.data;
            
        } catch (error) {
            console.error(`API request failed (${endpoint}):`, error.message);
            return {
                success: false,
                error: error.message,
                endpoint
            };
        }
    }

    // AI APIs
    async copilot(prompt) {
        return await this.request('/copilot', { prompt });
    }

    async talkAI(prompt) {
        return await this.request('/talk-ai', { prompt });
    }

    async gemini(prompt) {
        return await this.request('/gemini', { prompt });
    }

    async chatGPT(prompt) {
        return await this.request('/chatgpt', { prompt });
    }

    async generateStory(prompt) {
        return await this.request('/story', { prompt });
    }

    async generateMusic(prompt) {
        return await this.request('/musicgen', { prompt });
    }

    // Image APIs
    async generateImage(prompt) {
        return await this.request('/image', { prompt });
    }

    async generateFluxImage(prompt) {
        return await this.request('/flux', { prompt });
    }

    async generateFireLogo(text) {
        return await this.request('/firelogo', { text });
    }

    async generateQRCode(text) {
        return await this.request('/qr', { text });
    }

    // Tools APIs
    async screenshot(url) {
        return await this.request('/ssweb', { url });
    }

    async generateWhatsAppProfile(name) {
        return await this.request('/getpp', { name });
    }

    async webScrape(url) {
        return await this.request('/fetchpage', { url });
    }

    async vocalRemover(audioUrl) {
        return await this.request('/vocalremove', { url: audioUrl });
    }

    async ocr(imageUrl) {
        return await this.request('/ocr', { url: imageUrl });
    }

    async searchAPK(query) {
        return await this.request('/apk', { q: query });
    }

    async searchWallpaper(query) {
        return await this.request('/wallpaper', { q: query });
    }

    async searchFDroid(query) {
        return await this.request('/fdriod', { q: query });
    }

    async generateInsult() {
        return await this.request('/insult');
    }

    // Search APIs
    async searchYouTube(query) {
        return await this.request('/ytsearch', { q: query });
    }

    async searchSpotify(query) {
        return await this.request('/sps', { q: query });
    }

    async searchInstagram(username) {
        return await this.request('/igsearch', { username });
    }

    async searchTikTok(username) {
        return await this.request('/tiktokstalk', { username });
    }

    async search4KWallpaper(query) {
        return await this.request('/4kwallpaper', { q: query });
    }

    // Download APIs
    async downloadYouTube(url, format = 'mp3') {
        return await this.request('/ytdown', { url, format });
    }

    async downloadTwitter(url) {
        return await this.request('/x', { url });
    }

    async downloadAllInOne(url) {
        return await this.request('/aio', { url });
    }

    async downloadSpotify(url) {
        return await this.request('/spotify', { url });
    }

    async downloadFacebook(url) {
        return await this.request('/facebook', { url });
    }

    async downloadInstagram(url) {
        return await this.request('/instagram', { url });
    }

    async downloadTikTok(url) {
        return await this.request('/tiktok', { url });
    }

    async downloadMediafire(url) {
        return await this.request('/mediafire', { url });
    }

    // NSFW (with caution)
    async nsfw(random = true, search = '') {
        const params = random ? { random: 'true' } : { s: search };
        return await this.request('/nsfw', params);
    }

    // Helper methods
    clearCache() {
        this.cache.clear();
        return true;
    }

    getCacheStats() {
        return {
            size: this.cache.size,
            endpoints: Array.from(this.cache.keys()).map(key => key.split(':')[0])
        };
    }

    // Get all available APIs
    getAvailableAPIs() {
        return {
            ai: ['copilot', 'talk-ai', 'gemini', 'chatgpt', 'story', 'musicgen'],
            image: ['image', 'flux', 'firelogo', 'qr'],
            tools: ['ssweb', 'getpp', 'fetchpage', 'vocalremove', 'ocr', 'apk', 'wallpaper', 'fdriod', 'insult'],
            search: ['ytsearch', 'sps', 'igsearch', 'tiktokstalk', '4kwallpaper'],
            download: ['ytdown', 'x', 'aio', 'spotify', 'facebook', 'instagram', 'tiktok', 'mediafire'],
            nsfw: ['nsfw']
        };
    }
}

module.exports = EliteProTechAPI;
EOF
```

Update Chatbot to use EliteProTech APIs

```bash
cat > src/modules/Chatbot.js << 'EOF'
const axios = require('axios');
const config = require('../../config/config');
const settings = require('../../config/settings');
const EliteProTechAPI = require('./EliteProTechAPI');

class Chatbot {
    constructor() {
        this.api = new EliteProTechAPI();
        this.providers = {
            'copilot': this.copilot.bind(this),
            'talk-ai': this.talkAI.bind(this),
            'gemini': this.gemini.bind(this),
            'chatgpt': this.chatGPT.bind(this),
            'megan-fast': this.meganFast.bind(this)
        };
        
        this.contexts = new Map();
        this.history = new Map();
        this.maxHistory = 10;
    }

    // Get user context
    getUserContext(userId) {
        if (!this.contexts.has(userId)) {
            this.contexts.set(userId, {
                userId,
                conversation: [],
                preferences: {},
                lastActive: Date.now()
            });
        }
        return this.contexts.get(userId);
    }

    // Add to conversation history
    addToHistory(userId, role, message) {
        if (!this.history.has(userId)) {
            this.history.set(userId, []);
        }
        
        const history = this.history.get(userId);
        history.push({ role, message, timestamp: Date.now() });
        
        // Keep only last N messages
        if (history.length > this.maxHistory) {
            this.history.set(userId, history.slice(-this.maxHistory));
        }
    }

    // Get conversation history
    getHistory(userId) {
        return this.history.get(userId) || [];
    }

    // EliteProTech APIs
    async copilot(prompt, context = {}) {
        const response = await this.api.copilot(prompt);
        return this.formatAIResponse(response, 'copilot');
    }

    async talkAI(prompt, context = {}) {
        const response = await this.api.talkAI(prompt);
        return this.formatAIResponse(response, 'talk-ai');
    }

    async gemini(prompt, context = {}) {
        const response = await this.api.gemini(prompt);
        return this.formatAIResponse(response, 'gemini');
    }

    async chatGPT(prompt, context = {}) {
        const response = await this.api.chatGPT(prompt);
        return this.formatAIResponse(response, 'chatgpt');
    }

    // Megan Fast fallback
    async meganFast(prompt, context = {}) {
        try {
            const response = await axios.post(
                'https://late-salad-9d56.youngwanga254.workers.dev',
                {
                    prompt: prompt,
                    model: '@cf/meta/llama-3.1-8b-instruct',
                    context: context
                },
                { timeout: config.AI_TIMEOUT }
            );
            
            return {
                success: true,
                response: response.data.data?.response || this.fallbackResponse(prompt),
                provider: 'megan-fast',
                model: 'llama-3.1-8b-instruct'
            };
        } catch (error) {
            return {
                success: false,
                error: error.message,
                response: this.fallbackResponse(prompt)
            };
        }
    }

    // Format API response
    formatAIResponse(apiResponse, provider) {
        if (!apiResponse.success) {
            return {
                success: false,
                error: apiResponse.error,
                response: this.fallbackResponse(''),
                provider
            };
        }

        // Handle different response formats
        let responseText = '';
        if (typeof apiResponse === 'string') {
            responseText = apiResponse;
        } else if (apiResponse.response) {
            responseText = apiResponse.response;
        } else if (apiResponse.data) {
            responseText = apiResponse.data;
        } else {
            responseText = JSON.stringify(apiResponse);
        }

        return {
            success: true,
            response: responseText,
            provider,
            raw: apiResponse
        };
    }

    // Main chat method
    async chat(prompt, userId, options = {}) {
        try {
            const userSettings = settings.getUserSettings(userId);
            const provider = options.provider || userSettings.aiProvider || config.AI_PROVIDER;
            
            // Get user context
            const context = this.getUserContext(userId);
            
            // Add user message to history
            this.addToHistory(userId, 'user', prompt);
            
            // Get AI handler
            const handler = this.providers[provider] || this.providers['copilot'];
            
            // Prepare context with history
            const chatContext = {
                ...context,
                userId,
                history: this.getHistory(userId),
                settings: userSettings,
                timestamp: Date.now()
            };

            // Get AI response
            const result = await handler(prompt, chatContext);
            
            if (result.success) {
                // Add AI response to history
                this.addToHistory(userId, 'assistant', result.response);
                
                // Update context
                context.lastQuery = prompt;
                context.lastResponse = result.response;
                context.providerUsed = result.provider;
                context.lastActive = Date.now();

                return {
                    ...result,
                    context: chatContext,
                    historyLength: this.getHistory(userId).length
                };
            } else {
                return {
                    success: false,
                    response: this.fallbackResponse(prompt),
                    error: result.error,
                    provider: 'fallback'
                };
            }
        } catch (error) {
            return {
                success: false,
                response: this.fallbackResponse(prompt),
                error: error.message,
                provider: 'error-fallback'
            };
        }
    }

    // Fallback responses
    fallbackResponse(prompt) {
        const responses = [
            `I understand you said: "${prompt.substring(0, 50)}..."`,
            `Processing your message...`,
            `Thanks for your message! How can I assist you further?`,
            `I heard: "${prompt.substring(0, 30)}" - could you elaborate?`,
            `That's interesting! Tell me more.`,
            `I'm here to help! What else would you like to know?`,
            `Got it! Is there anything specific you'd like me to help with?`
        ];
        
        return responses[Math.floor(Math.random() * responses.length)];
    }

    // Clear user history
    clearHistory(userId) {
        this.history.delete(userId);
        this.contexts.delete(userId);
        return true;
    }

    // Get chatbot stats
    getStats() {
        return {
            activeUsers: this.contexts.size,
            totalHistory: Array.from(this.history.values()).reduce((sum, hist) => sum + hist.length, 0),
            providers: Object.keys(this.providers),
            apiStats: this.api.getCacheStats()
        };
    }

    // Generate image
    async generateImage(prompt) {
        return await this.api.generateImage(prompt);
    }

    // Generate story
    async generateStory(prompt) {
        return await this.api.generateStory(prompt);
    }

    // Generate music
    async generateMusic(prompt) {
        return await this.api.generateMusic(prompt);
    }
}

module.exports = Chatbot;
EOF
```

Create YouTube Tools Commands

```bash
mkdir -p src/commands/tools
cat > src/commands/tools/youtube.js << 'EOF'
module.exports = {
    name: 'youtube',
    aliases: ['yt', 'music', 'video'],
    category: 'tools',
    description: 'Search and download from YouTube',
    usage: '.youtube search [query]\n.youtube download [url] [mp3/mp4]',
    cooldown: 10,
    
    async execute({ bot, msg, from, args, config, logger }) {
        try {
            const action = args[0]?.toLowerCase();
            
            if (!action || !['search', 'download'].includes(action)) {
                return `ðŸŽ¬ *YouTube Tools*\n\n` +
                       `*Search:* ${config.PREFIX}youtube search [song name]\n` +
                       `*Download:* ${config.PREFIX}youtube download [url] [mp3/mp4]\n\n` +
                       `*Examples:*\n` +
                       `â€¢ ${config.PREFIX}yt search Ndovu ni kuu\n` +
                       `â€¢ ${config.PREFIX}yt download https://youtube.com/watch?v=... mp3`;
            }
            
            if (action === 'search') {
                const query = args.slice(1).join(' ');
                if (!query) {
                    return 'âŒ Please provide a search query.\n' +
                           `*Example:* ${config.PREFIX}youtube search Ndovu ni kuu`;
                }
                
                // Send processing reaction
                await bot.sock.sendMessage(from, {
                    react: { text: 'ðŸ”', key: msg.key }
                });
                
                // Search YouTube
                const searchResults = await bot.chatbot.api.searchYouTube(query);
                
                if (!searchResults.success || !searchResults.results?.videos?.length) {
                    return 'âŒ No results found. Try a different search query.';
                }
                
                const videos = searchResults.results.videos.slice(0, 5);
                
                let response = `ðŸ” *YouTube Search: "${query}"*\n\n`;
                
                videos.forEach((video, index) => {
                    response += `*${index + 1}. ${video.title}*\n`;
                    response += `â±ï¸ Duration: ${video.duration}\n`;
                    response += `ðŸ‘ï¸ Views: ${video.views.toLocaleString()}\n`;
                    response += `ðŸ‘¤ Channel: ${video.author.name}\n`;
                    response += `ðŸ”— ${video.url}\n\n`;
                });
                
                response += `*To download:*\n${config.PREFIX}youtube download [URL] [mp3/mp4]\n`;
                response += `*Example:* ${config.PREFIX}youtube download ${videos[0].url} mp3`;
                
                await bot.sendMessage(from, {
                    text: response,
                    footer: config.BOT_NAME
                }, { quoted: msg });
                
                logger.apiRequest('EliteProTech', 'ytsearch', 'success');
                return `Search results for: ${query}`;
                
            } else if (action === 'download') {
                const url = args[1];
                const format = args[2]?.toLowerCase() || 'mp3';
                
                if (!url || !url.includes('youtube.com') && !url.includes('youtu.be')) {
                    return 'âŒ Please provide a valid YouTube URL.\n' +
                           `*Example:* ${config.PREFIX}youtube download https://youtube.com/watch?v=... mp3`;
                }
                
                if (!['mp3', 'mp4'].includes(format)) {
                    return 'âŒ Invalid format. Use mp3 (audio) or mp4 (video).';
                }
                
                // Send processing reaction
                await bot.sock.sendMessage(from, {
                    react: { text: 'â¬', key: msg.key }
                });
                
                const processingMsg = await bot.sendMessage(from, {
                    text: `â³ Downloading ${format.toUpperCase()}...\nThis may take a moment.`,
                    footer: config.BOT_NAME
                }, { quoted: msg });
                
                // Download from YouTube
                const downloadResult = await bot.chatbot.api.downloadYouTube(url, format);
                
                if (!downloadResult.success || !downloadResult.downloadURL) {
                    await bot.sock.sendMessage(from, {
                        text: `âŒ Download failed: ${downloadResult.error || 'Unknown error'}`,
                        edit: processingMsg.key
                    });
                    return 'Download failed';
                }
                
                const fileSize = format === 'mp3' ? '3-10MB' : '10-50MB';
                
                await bot.sock.sendMessage(from, {
                    text: `âœ… *Download Complete!*\n\n` +
                          `ðŸ“ *Title:* ${downloadResult.title || 'Unknown'}\n` +
                          `ðŸ“ *Format:* ${format.toUpperCase()}\n` +
                          `ðŸ“¦ *Size:* ${fileSize}\n\n` +
                          `â¬ *Download Link:*\n${downloadResult.downloadURL}\n\n` +
                          `âš ï¸ *Note:* Link expires in 24 hours\n` +
                          `ðŸŽµ Enjoy your ${format === 'mp3' ? 'music' : 'video'}!`,
                    edit: processingMsg.key
                });
                
                logger.apiRequest('EliteProTech', 'ytdown', 'success');
                return `Downloaded ${format}: ${downloadResult.title || 'Unknown'}`;
            }
            
        } catch (error) {
            logger.error(`YouTube command failed: ${error.message}`, 'TOOLS');
            return `âŒ Error: ${error.message}`;
        }
    }
};
EOF
```

Create Image Generation Command

```bash
cat > src/commands/tools/imagegen.js << 'EOF'
module.exports = {
    name: 'imagegen',
    aliases: ['generate', 'aiimage', 'flux'],
    category: 'tools',
    description: 'Generate AI images',
    usage: '.imagegen [prompt]',
    cooldown: 15,
    
    async execute({ bot, msg, from, args, config, logger }) {
        try {
            const prompt = args.join(' ');
            
            if (!prompt || prompt.length < 3) {
                return `ðŸŽ¨ *AI Image Generator*\n\n` +
                       `Generate images using AI.\n\n` +
                       `*Usage:* ${config.PREFIX}imagegen [description]\n` +
                       `*Examples:*\n` +
                       `â€¢ ${config.PREFIX}imagegen a beautiful sunset over mountains\n` +
                       `â€¢ ${config.PREFIX}imagegen futuristic city at night\n` +
                       `â€¢ ${config.PREFIX}imagegen cute anime character`;
            }
            
            // Send processing reaction
            await bot.sock.sendMessage(from, {
                react: { text: 'ðŸŽ¨', key: msg.key }
            });
            
            const processingMsg = await bot.sendMessage(from, {
                text: `ðŸŽ¨ Generating image: "${prompt.substring(0, 50)}..."\nThis may take 10-30 seconds.`,
                footer: config.BOT_NAME
            }, { quoted: msg });
            
            // Generate image
            const imageResult = await bot.chatbot.api.generateImage(prompt);
            
            if (!imageResult.success || !imageResult.imageUrl) {
                // Try Flux as fallback
                const fluxResult = await bot.chatbot.api.generateFluxImage(prompt);
                
                if (!fluxResult.success || !fluxResult.imageUrl) {
                    await bot.sock.sendMessage(from, {
                        text: `âŒ Image generation failed. Try a different prompt.`,
                        edit: processingMsg.key
                    });
                    return 'Image generation failed';
                }
                
                imageResult.imageUrl = fluxResult.imageUrl;
            }
            
            // Download image
            const axios = require('axios');
            const imageResponse = await axios.get(imageResult.imageUrl, {
                responseType: 'arraybuffer',
                timeout: 30000
            });
            
            const imageBuffer = Buffer.from(imageResponse.data, 'binary');
            
            // Send image
            await bot.sendMessage(from, {
                image: imageBuffer,
                caption: `ðŸŽ¨ *AI Generated Image*\n\n` +
                        `ðŸ“ *Prompt:* ${prompt}\n` +
                        `âš™ï¸ *Model:* ${config.BOT_NAME} Image AI\n\n` +
                        `ðŸ’¡ *Tip:* Be specific in your descriptions for better results!`
            }, { quoted: msg });
            
            // Delete processing message
            await bot.sock.sendMessage(from, {
                delete: processingMsg.key
            });
            
            logger.apiRequest('EliteProTech', 'image', 'success');
            return `Image generated: ${prompt.substring(0, 30)}...`;
            
        } catch (error) {
            logger.error(`Image generation failed: ${error.message}`, 'TOOLS');
            return `âŒ Error: ${error.message}`;
        }
    }
};
EOF
```

Create Tools Menu Command

```bash
cat > src/commands/tools/menu.js << 'EOF'
module.exports = {
    name: 'tools',
    aliases: ['features', 'apis'],
    category: 'tools',
    description: 'Show available tools and APIs',
    usage: '.tools',
    cooldown: 5,
    
    async execute({ bot, msg, from, config, logger }) {
        try {
            const apis = bot.chatbot.api.getAvailableAPIs();
            
            let menu = `ðŸ› ï¸ *${config.BOT_NAME} TOOLS & APIS*\n\n`;
            
            menu += `ðŸ¤– *AI Chatbots:*\n`;
            menu += `â€¢ ${config.PREFIX}ai [question] - Chat with AI\n`;
            menu += `â€¢ ${config.PREFIX}story [prompt] - Generate stories\n`;
            menu += `â€¢ ${config.PREFIX}musicgen [prompt] - Generate music\n\n`;
            
            menu += `ðŸŽ¨ *Image Generation:*\n`;
            menu += `â€¢ ${config.PREFIX}imagegen [prompt] - Create AI images\n`;
            menu += `â€¢ ${config.PREFIX}firelogo [text] - Generate fire logos\n`;
            menu += `â€¢ ${config.PREFIX}qr [text] - Create QR codes\n\n`;
            
            menu += `ðŸŽ¬ *YouTube Tools:*\n`;
            menu += `â€¢ ${config.PREFIX}youtube search [query] - Search videos\n`;
            menu += `â€¢ ${config.PREFIX}youtube download [url] [mp3/mp4] - Download\n\n`;
            
            menu += `ðŸ” *Search Tools:*\n`;
            menu += `â€¢ ${config.PREFIX}wallpaper [query] - Find wallpapers\n`;
            menu += `â€¢ ${config.PREFIX}apk [app] - Search APK files\n`;
            menu += `â€¢ ${config.PREFIX}spotify [song] - Search music\n\n`;
            
            menu += `ðŸ“¥ *Downloaders:*\n`;
            menu += `â€¢ Instagram, Facebook, TikTok, Twitter\n`;
            menu += `â€¢ Spotify, MediaFire,
